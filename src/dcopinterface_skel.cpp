/****************************************************************************
**
** DCOP Skeleton generated by dcopidl2cpp from dcopinterface.kidl
**
** WARNING! All changes made in this file will be lost!
**
*****************************************************************************/

#include "/home/robby/projects/tellico/src/dcopinterface.h"

#include <kdatastream.h>
#include <qasciidict.h>

namespace Tellico {

static const int DCOPInterface_fhash = 11;
static const char* const DCOPInterface_ftable[11][3] = {
    { "bool", "importTellico(QString,QString)", "importTellico(QString file,QString action)" },
    { "bool", "importBibtex(QString,QString)", "importBibtex(QString file,QString action)" },
    { "bool", "importMODS(QString,QString)", "importMODS(QString file,QString action)" },
    { "bool", "importRIS(QString,QString)", "importRIS(QString file,QString action)" },
    { "bool", "exportXML(QString)", "exportXML(QString file)" },
    { "bool", "exportBibtex(QString)", "exportBibtex(QString file)" },
    { "bool", "exportHTML(QString)", "exportHTML(QString file)" },
    { "bool", "exportCSV(QString)", "exportCSV(QString file)" },
    { "bool", "exportPilotDB(QString)", "exportPilotDB(QString file)" },
    { "QStringList", "bibtexKeys()", "bibtexKeys()" },
    { 0, 0, 0 }
};
static const int DCOPInterface_ftable_hiddens[10] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool DCOPInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( DCOPInterface_fhash, true, false );
	for ( int i = 0; DCOPInterface_ftable[i][1]; i++ )
	    fdict->insert( DCOPInterface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // bool importTellico(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = DCOPInterface_ftable[0][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << importTellico(arg0, arg1 );
    } break;
    case 1: { // bool importBibtex(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = DCOPInterface_ftable[1][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << importBibtex(arg0, arg1 );
    } break;
    case 2: { // bool importMODS(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = DCOPInterface_ftable[2][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << importMODS(arg0, arg1 );
    } break;
    case 3: { // bool importRIS(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = DCOPInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << importRIS(arg0, arg1 );
    } break;
    case 4: { // bool exportXML(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = DCOPInterface_ftable[4][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << exportXML(arg0 );
    } break;
    case 5: { // bool exportBibtex(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = DCOPInterface_ftable[5][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << exportBibtex(arg0 );
    } break;
    case 6: { // bool exportHTML(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = DCOPInterface_ftable[6][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << exportHTML(arg0 );
    } break;
    case 7: { // bool exportCSV(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = DCOPInterface_ftable[7][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << exportCSV(arg0 );
    } break;
    case 8: { // bool exportPilotDB(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = DCOPInterface_ftable[8][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << exportPilotDB(arg0 );
    } break;
    case 9: { // QStringList bibtexKeys()
	replyType = DCOPInterface_ftable[9][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << bibtexKeys( );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList DCOPInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "Tellico::DCOPInterface";
    return ifaces;
}

QCStringList DCOPInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; DCOPInterface_ftable[i][2]; i++ ) {
	if (DCOPInterface_ftable_hiddens[i])
	    continue;
	QCString func = DCOPInterface_ftable[i][0];
	func += ' ';
	func += DCOPInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}

} // namespace

