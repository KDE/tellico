/*************************************************************************
                             bibtexmlexporter.cpp
                             -------------------
    begin                : Sat Aug 2 2003
    copyright            : (C) 2003 by Robby Stephenson
    email                : robby@periapsis.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of version 2 of the GNU General Public License as  *
 *   published by the Free Software Foundation;                            *
 *                                                                         *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "bibtexmlexporter.h"
#include "bibtexhandler.h"
#include "../bccollection.h"
#include "../collections/bibtexcollection.h"
#include "../collections/bibtexattribute.h"

#include <klocale.h>

#include <qvbox.h>
#include <qdom.h>
#include <qregexp.h>
#include <qtextcodec.h>

static const char* BIBTEXML_DTD = "bibtexml.dtd";

QString BibtexmlExporter::formatString() const {
  return i18n("Bibtexml");
}

QString BibtexmlExporter::fileFilter() const {
  return i18n("*.xml|Bibtexml files (*.xml)") + QString::fromLatin1("\n") + i18n("*|All files");
}

QString BibtexmlExporter::text(bool formatAttributes_, bool encodeUTF8_) {
  if(collection()->collectionType() != BCCollection::Bibtex) {
    return QString::null;
  }

  QString entryTypeName, keyName;
  BibtexAttributeList attList;
  BCAttributeListIterator it(collection()->attributeList());
  for( ; it.current(); ++it) {
    if(it.current()->isBibtexAttribute()) {
      BibtexAttribute* batt = dynamic_cast<BibtexAttribute*>(it.current());
      if(!batt->bibtexFieldName().isEmpty()) {
        if(batt->bibtexFieldName() == QString::fromLatin1("entry-type")) {
          entryTypeName = batt->name();
        } else if(batt->bibtexFieldName() == QString::fromLatin1("key")) {
          keyName = batt->name();
        } else {
          attList.append(batt);
        }
      }
    }
  }

  QDomImplementation impl;
  QDomDocumentType doctype = impl.createDocumentType(QString::fromLatin1("file"),
                                                     QString::null,
                                                     QString::fromLatin1(BIBTEXML_DTD));
  //default namespace
  QString ns = BibtexHandler::s_bibtexmlNamespace;

  QDomDocument dom = impl.createDocument(ns, QString::fromLatin1("file"), doctype);

  // root bookcase element
  QDomElement bcelem = dom.documentElement();

  QString encodeStr = QString::fromLatin1("version=\"1.0\" encoding=\"");
  if(encodeUTF8_) {
    encodeStr += QString::fromLatin1("UTF-8");
  } else {
    encodeStr += QString::fromLatin1(QTextCodec::codecForLocale()->mimeName());
  }
  encodeStr += QString::fromLatin1("\"");
  
  // createDocument creates a root node, insert the processing instruction before it
  dom.insertBefore(dom.createProcessingInstruction(QString::fromLatin1("xml"), encodeStr), bcelem);
  QString comment = QString::fromLatin1("Generated by Bookcase ") + QString::fromLatin1(VERSION);
  dom.insertBefore(dom.createComment(comment), bcelem);

  const BibtexCollection* c = dynamic_cast<const BibtexCollection*>(collection());
  QStringList macros;
  if(c) {
    macros = c->macroList().keys();
  }

  QString entryName, key, attText;
  QDomElement entryElem, unitElem, attParElem, attElem;
  BibtexAttributeListIterator attIt(attList);
  BCUnitListIterator unitIt(unitList());
  for( ; unitIt.current(); ++unitIt) {
    key = unitIt.current()->attribute(keyName);
    if(key.isEmpty()) {
      key = BibtexHandler::bibtexKey(unitIt.current());
    }
    entryElem = dom.createElement(QString::fromLatin1("entry"));
    entryElem.setAttribute(QString::fromLatin1("id"), key);
    bcelem.appendChild(entryElem);
    
    entryName = unitIt.current()->attribute(entryTypeName);
    if(entryName.isEmpty()) {
      continue;
    }
    
    unitElem = dom.createElement(entryName);
    entryElem.appendChild(unitElem);

    // now iterate over attributes
    attIt.toFirst();
    for( ; attIt.current(); ++attIt) {
      // get attribute value
      if(formatAttributes_) {
        attText = unitIt.current()->attributeFormatted(attIt.current()->name(), attIt.current()->formatFlag());
      } else {
        attText = unitIt.current()->attribute(attIt.current()->name());
      }
      if(attText.isEmpty()) {
        continue;
      }

/* Bibtexml has special container elements for titles, authors, editors, and keywords
   I'm going to ignore the titlelist element for right now. All authors are contained in
   an authorlist element, editors in an editorlist element, and keywords are in a
   keywords element, and themselves as a keyword. Also, Bibtexml can format names
   similar to docbook, with first, middle, last, etc elements. I'm going to ignroe that
   for now, too.*/
      QString elemName = attIt.current()->bibtexFieldName();
      // split text for author, editor, and keywords
      if(attIt.current()->flags() & BCAttribute::AllowMultiple
         && (elemName == QString::fromLatin1("author")
             || elemName == QString::fromLatin1("editor")
             || elemName == QString::fromLatin1("keywords"))) {
        QString parElemName;
        if(elemName == QString::fromLatin1("author")) {
          parElemName = QString::fromLatin1("authorlist");
        } else if(elemName == QString::fromLatin1("editor")) {
          parElemName = QString::fromLatin1("editorlist");
        } else { // keywords
          parElemName = QString::fromLatin1("keywords");
          elemName = QString::fromLatin1("keyword");
        }

        attParElem = dom.createElement(parElemName);
        QStringList values = QStringList::split(QRegExp(QString::fromLatin1("\\s*;\\s*")), attText, false);
        for(QStringList::Iterator it = values.begin(); it != values.end(); ++it) {
          attElem = dom.createElement(elemName);
          attElem.appendChild(dom.createTextNode(*it));
          attParElem.appendChild(attElem);
        }
        unitElem.appendChild(attParElem);
      } else {
        attElem = dom.createElement(elemName);
        attElem.appendChild(dom.createTextNode(attText));
        unitElem.appendChild(attElem);
      }
    }
  }

  return dom.toString();
}
