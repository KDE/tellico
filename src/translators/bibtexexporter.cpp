/***************************************************************************
                               bibtexexporter.cpp
                             -------------------
    begin                : Sat Aug 2 2003
    copyright            : (C) 2003 by Robby Stephenson
    email                : robby@periapsis.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of version 2 of the GNU General Public License as  *
 *   published by the Free Software Foundation;                            *
 *                                                                         *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "bibtexexporter.h"
#include "../bccollection.h"
#include "../collections/bibtexcollection.h"
#include "../collections/bibtexattribute.h"

#include <klocale.h>
#include <kdebug.h>
#include <kconfig.h>

#include <qregexp.h>
#include <qcheckbox.h>
#include <qlayout.h>
#include <qgroupbox.h>
#include <qwhatsthis.h>

BibtexExporter::BibtexExporter(const BCCollection* coll_, const BCUnitList& list_) : Exporter(coll_, list_),
   m_expandMacros(false),
   m_packageURL(true),
   m_quoteStyle(BibtexHandler::BRACES),
   m_widget(0) {
}

QString BibtexExporter::formatString() const {
  return i18n("Bibtex");
}

QString BibtexExporter::fileFilter() const {
  return i18n("*.bib|Bibtex files (*.bib)") + QString::fromLatin1("\n") + i18n("*|All files");
}

QWidget* BibtexExporter::widget(QWidget* parent_, const char* name_/*=0*/) {
  if(m_widget && m_widget->parent() == parent_) {
    return m_widget;
  }

  m_widget = new QWidget(parent_, name_);
  QVBoxLayout* l = new QVBoxLayout(m_widget);

  QGroupBox* box = new QGroupBox(1, Qt::Horizontal, i18n("Bibtex Options"), m_widget);
  l->addWidget(box);

  m_checkExpandMacros = new QCheckBox(i18n("Expand string macros"), box);
  m_checkExpandMacros->setChecked(m_expandMacros);
  QWhatsThis::add(m_checkExpandMacros, i18n("If checked, the string macros will be expanded and no "
                                            "@string{} entries will be written."));

  m_checkPackageURL = new QCheckBox(i18n("Use URL package"), box);
  m_checkPackageURL->setChecked(m_packageURL);
  QWhatsThis::add(m_checkPackageURL, i18n("If checked, any URL fields will be wrapped in a "
                                          "\\url declaration."));

  l->addStretch(1);
  return m_widget;
}

void BibtexExporter::readOptions(KConfig* config_) {
  config_->setGroup(QString::fromLatin1("ExportOptions - %1").arg(formatString()));
  m_expandMacros = config_->readBoolEntry("Expand Macros", m_expandMacros);
  m_packageURL = config_->readBoolEntry("URL Package", m_packageURL);
}

void BibtexExporter::saveOptions(KConfig* config_) {
  config_->setGroup(QString::fromLatin1("ExportOptions - %1").arg(formatString()));
  m_expandMacros = m_checkExpandMacros->isChecked();
  config_->writeEntry("Expand Macros", m_expandMacros);
  m_packageURL = m_checkPackageURL->isChecked();
  config_->writeEntry("URL Package", m_packageURL);
}

QString BibtexExporter::text(bool formatAttributes_, bool) {
// there are some special attributes
// the entry-type specifies the entry type - book, inproceedings, whatever
  QString typeAttribute;
// the key specifies the cite-key
  QString keyAttribute;
// keep a list of all the 'ordinary' fields to iterate through later
  BibtexAttributeList attList;
  BCAttributeListIterator it(collection()->attributeList());
  for( ; it.current(); ++it) {
    if(it.current()->isBibtexAttribute()) {
      BibtexAttribute* batt = dynamic_cast<BibtexAttribute*>(it.current());
      if(!batt->bibtexFieldName().isEmpty()) {
        if(batt->bibtexFieldName() == QString::fromLatin1("entry-type")) {
          typeAttribute = batt->name();
        } else if(batt->bibtexFieldName() == QString::fromLatin1("key")) {
          keyAttribute = batt->name();
        } else {
          attList.append(batt);
        }
      }
    }
  }

  if(typeAttribute.isEmpty() || keyAttribute.isEmpty()) {
    kdWarning() << "BibtexExporter::text() - the collection must have attributes defining "
                   "the entry-type and the key of the entry" << endl;
    return QString::null;
  }
  if(attList.isEmpty()) {
    kdWarning() << "BibtexExporter::text() - no bibtex field mapping exist in the collection." << endl;
    return QString::null;
  }
  
  QString text = QString::fromLatin1("@comment{Generated by Bookcase ");
  text += QString::fromLatin1(VERSION);
  text += QString::fromLatin1("}\n");

  const BibtexCollection* c = dynamic_cast<const BibtexCollection*>(collection());
  QStringList macros;
  if(c) {
    QString pre = c->preamble();
    if(!pre.isEmpty()) {
      text += QString::fromLatin1("@preamble{") + pre + QString::fromLatin1("}\n");
    }
    
    if(!m_expandMacros) {
      macros = c->macroList().keys();
      QMap<QString, QString>::ConstIterator macroIt;
      for(macroIt = c->macroList().begin(); macroIt != c->macroList().end(); ++macroIt) {
        if(!macroIt.data().isEmpty()) {
          text += QString::fromLatin1("@string{")
                  + macroIt.key()
                  + QString::fromLatin1("=")
                  + BibtexHandler::exportText(macroIt.data(), macros)
                  + QString::fromLatin1("}\n");
        }
      }
    }
  }
  
  QString value;
  BibtexAttributeListIterator attIt(attList);
  BCUnitListIterator unitIt(unitList());
  for( ; unitIt.current(); ++unitIt) {
    value = unitIt.current()->attribute(typeAttribute);
    if(value.isEmpty()) {
      kdWarning() << "BibtexExporter::text() - this entry has no entry-type!" << endl;
      continue;
    }
    text += QString::fromLatin1("@") + value + QString::fromLatin1("{");

    value = unitIt.current()->attribute(keyAttribute);
    // this is left-over, can I remove it?
    if(value.isEmpty()) {
      value = unitIt.current()->attribute(QString::fromLatin1("bibtex-id"));
    }
    if(value.isEmpty()) {
      value = BibtexHandler::bibtexKey(unitIt.current());
    }
    text += value;
    
    attIt.toFirst();
    for( ; attIt.current(); ++attIt) {
      if(formatAttributes_) {
        value = unitIt.current()->attributeFormatted(attIt.current()->name(), attIt.current()->formatFlag());
      } else {
        value = unitIt.current()->attribute(attIt.current()->name());
      }
      // If the entry is formatted as a name and allow multiple values
      // insert "and" in between them (e.g. author and editor)
      if(attIt.current()->formatFlag() == BCAttribute::FormatName
         && attIt.current()->flags() & BCAttribute::AllowMultiple) {
        value.replace(QRegExp(QString::fromLatin1("\\s?;\\s?")), QString::fromLatin1(" and "));
      }
      if(!value.isEmpty()) {
        if(m_packageURL && attIt.current()->type() == BCAttribute::URL) {
          value = QString::fromLatin1("\\url{") + value + QString::fromLatin1("}");
        } else if(attIt.current()->type() != BCAttribute::Number) {
        // numbers aren't escaped, nor will they have macros
          // if m_expandMacros is true, then macros is empty, so this is ok even then
          value = BibtexHandler::exportText(value, macros);
        }
        text += QString::fromLatin1(",\n  ");
        text += attIt.current()->bibtexFieldName();
        text += QString::fromLatin1(" = ");
        text += value;
      }
    }
    text += QString::fromLatin1("\n}\n");
  }
  return text;
}
