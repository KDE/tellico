<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:bc="http://periapsis.org/bookcase/"
                xmlns:str="http://exslt.org/strings"
                xmlns:bibtexml="http://bibtexml.sf.net/"
                extension-element-prefixes="str"
                exclude-result-prefixes="bc str"
                version="1.0">

<!--
   ================================================================
   Bookcase XSLT file - used for exporting to bibtexml format

   $Id: bookcase2bibtexml.xsl,v 1.4 2003/05/06 05:10:55 robby Exp $

   Copyright (c) 2003 Robby Stephenson - robby@periapsis.org

   This XSLT stylesheet is designed to be used with XML data files
   from the 'Bookcase' application, which can be found at:
   http://www.periapsis.org/bookcase/
   ================================================================
-->

<xsl:output method="xml" version="1.0" indent="yes"
            encoding="UTF-8"
            doctype-system="http://bibtexml.sf.net/bibtexml.dtd"
            doctype-public="-//Oren Patashnik//DTD bibtex//EN"/>

<xsl:strip-space elements="*"/>

<xsl:variable name="current-syntax" select="'3'"/>

<!--make lowercase easier -->
<xsl:variable name="lc" select="'abcdefghijklmnopqrstuvwxyz'"/>
<xsl:variable name="uc" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<xsl:variable name="endl">
<xsl:text>
</xsl:text>
</xsl:variable>

<xsl:template match="/">
 <xsl:apply-templates select="bc:bookcase"/>
</xsl:template>

<xsl:template match="bc:bookcase">
 <xsl:if test="not(@syntaxVersion = $current-syntax)">
  <xsl:message>
   <xsl:text>This stylesheet was designed for Bookcase DTD version </xsl:text>
   <xsl:value-of select="$current-syntax"/>
   <xsl:text>, </xsl:text>
   <xsl:value-of select="$endl"/>
   <xsl:text>but the data file is version </xsl:text>
   <xsl:value-of select="@syntaxVersion"/>
   <xsl:text>.</xsl:text>
  </xsl:message>
 </xsl:if>
 <xsl:comment>
  <xsl:text>Generated by Bookcase </xsl:text>
  <xsl:value-of select="$version"/>
 </xsl:comment>
 <xsl:value-of select="$endl"/>
 <bibtexml:file>
  <xsl:apply-templates select="bc:collection/bc:book"/>
 </bibtexml:file>
</xsl:template>

<xsl:template match="bc:book">
 <!-- year might have multiple values, show publication year is present
      otherwise,  show first copyright year -->
 <xsl:variable name="year">
  <xsl:choose>
   <xsl:when test="bc:pub_year">
    <xsl:value-of select="bc:pub_year"/>
   </xsl:when>
   <xsl:otherwise>
    <xsl:value-of select="bc:cr_years/bc:cr_year[1]"/>
   </xsl:otherwise>
  </xsl:choose>
 </xsl:variable>

 <bibtexml:entry>
  <xsl:attribute name="bibtexml:id">
   <xsl:choose>
    <xsl:when test="bc:bibtex-id">
     <xsl:value-of select="bc:bibtex-id"/>
    </xsl:when>
    <xsl:otherwise>
     <xsl:call-template name="make-key">
      <xsl:with-param name="author" select="bc:authors/bc:author[1]"/>
      <xsl:with-param name="title" select="bc:title"/>
      <xsl:with-param name="year" select="$year"/>
     </xsl:call-template>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:attribute>

  <bibtexml:book>
   <xsl:apply-templates select="bc:authors|bc:title|bc:publisher|bc:isbn|bc:lccn|bc:edition|bc:series|bc:series_num|bc:keywords|bc:languages|bc:price|bc:comments"/>
   <xsl:if test="string-length($year)">
    <bibtexml:year>
     <xsl:value-of select="$year"/>
    </bibtexml:year>
   </xsl:if>
  </bibtexml:book>
 </bibtexml:entry>
</xsl:template>

<xsl:template match="bc:authors">
 <bibtexml:author>
  <xsl:for-each select="bc:author">
   <xsl:value-of select="."/>
   <xsl:if test="not(position() = last())">
    <xsl:text>; </xsl:text>
   </xsl:if>
  </xsl:for-each>
 </bibtexml:author>
</xsl:template>

<xsl:template match="bc:title">
 <bibtexml:title>
  <xsl:value-of select="."/>
 </bibtexml:title>
</xsl:template>

<xsl:template match="bc:publisher">
 <bibtexml:publisher>
  <xsl:value-of select="."/>
 </bibtexml:publisher>
</xsl:template>

<xsl:template match="bc:isbn">
 <bibtexml:isbn>
  <xsl:value-of select="."/>
 </bibtexml:isbn>
</xsl:template>

<xsl:template match="bc:lccn">
 <bibtexml:lccn>
  <xsl:value-of select="."/>
 </bibtexml:lccn>
</xsl:template>

<!-- TODO: this should be ordinal,  and capitalized -->
<xsl:template match="bc:edition">
 <bibtexml:edition>
  <xsl:value-of select="."/>
 </bibtexml:edition>
</xsl:template>

<xsl:template match="bc:series">
 <bibtexml:series>
  <xsl:value-of select="."/>
 </bibtexml:series>
</xsl:template>

<xsl:template match="bc:series_num">
 <bibtexml:number>
  <xsl:value-of select="."/>
 </bibtexml:number>
</xsl:template>

<xsl:template match="bc:keywords">
 <bibtexml:keywords>
  <xsl:for-each select="bc:keyword">
   <xsl:value-of select="translate(., $uc, $lc)"/>
   <xsl:if test="not(position() = last())">
    <xsl:text>, </xsl:text>
   </xsl:if>
  </xsl:for-each>
 </bibtexml:keywords>
</xsl:template>

<xsl:template match="bc:languages">
 <bibtexml:language>
  <xsl:for-each select="bc:language">
   <xsl:value-of select="translate(., $uc, $lc)"/>
   <xsl:if test="not(position() = last())">
    <xsl:text>, </xsl:text>
   </xsl:if>
  </xsl:for-each>
 </bibtexml:language>
</xsl:template>

<xsl:template match="bc:price">
 <bibtexml:price>
  <xsl:value-of select="."/>
 </bibtexml:price>
</xsl:template>

<xsl:template match="bc:comments">
 <bibtexml:note>
  <xsl:value-of select="."/>
 </bibtexml:note>
</xsl:template>

<!-- TODO: figure out how to make this unique -->
<!-- format is (last name of first author)-(initials of title)(year) -->
<xsl:template name="make-key">
 <xsl:param name="author"/>
 <xsl:param name="title"/>
 <xsl:param name="year"/>
 <xsl:variable name="word1">
  <xsl:choose>
   <xsl:when test="contains($author, ',')">
    <xsl:variable name="before-comma" select="substring-before($author, ',')"/>
    <xsl:variable name="words" select="str:tokenize($before-comma, ' ')"/>
    <xsl:value-of select="translate($words[last()], $uc, $lc)"/>
   </xsl:when>
   <xsl:otherwise>
    <xsl:variable name="words" select="str:tokenize($author, ' ')"/>
    <xsl:value-of select="translate($words[last()], $uc, $lc)"/>
   </xsl:otherwise>
  </xsl:choose> 
 </xsl:variable>
 <xsl:variable name="word2">
  <xsl:for-each select="str:tokenize($title, ' ')">
   <xsl:value-of select="translate(substring(., 1, 1), $uc, $lc)"/>
  </xsl:for-each>
 </xsl:variable>
 <xsl:value-of select="concat($word1, '-', $word2, $year)"/>
</xsl:template>

</xsl:stylesheet>
<!-- Local Variables: -->
<!-- sgml-indent-step: 1 -->
<!-- sgml-indent-data: 1 -->
<!-- End: -->
